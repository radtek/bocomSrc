
#include "BaoXinSdk.h"

#include "BaoXinNetProtol.h"

BX_CB_FUNS *g_bx_cb_funs = NULL;
BX_Int32 g_InitStat = 0;//初始化状态，防止被重复初始化

#define MAX_BUFFLEN  (2*1024*1024)

BX_Uint8 *g_pBX_JpegBuff = NULL;//宝信图片缓存区
BX_Int32 g_LastSendBuffLen = MAX_BUFFLEN;//上次发送此结果大小

//基本内嵌信息
BX_Uint8	g_pui8JPEGEmbededData[68] = {
	0xFF,0xD8,0xFF,0xE1,0x00,0x40,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x2C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x2C,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x2C,0x30,0x30,0x30,0x30,0x30,0x2C,0x30,0x30,0x30,0x30,0x2C,0x30,
	0x30,0x30,0x30,0x2C,0x30,0x2C,0x30,0x30,0x2C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30};

//车牌识别信息
BX_Uint8	g_pui8JPEGEmbededPlateRecogData[258] = {
						0xFF,0xE2,0x01,0x00,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x2C,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
	0x30,0x30,0x30,0x30,0x30,0x30};
//配置曝光参数信息（不是必须）		
BX_Uint8	g_pui8JPEGEmbededExposualData[66] = {
								  0xFF,0xE3,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};	

//（子图相关的信息）
BX_Uint8 g_pui8JPEGEmbededSubPhotoData[66]={
											0xFF,0xE4,0x00,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
//(图片防伪码)
BX_Uint8 g_pui8JPEGEmbededSecurityCode[24] ={
													  0xFF,0xE5,0x00,0x16,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00};
//(图片数字水印)
BX_Uint8 g_pui8JPEGEmbededWaterMarkData[24] = {
	0xFF,0xEF,0x00,0x16,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00};



BX_Int32 BX_Init()
{

	if (g_InitStat == 1)
	{
		return BX_RE_INIT;
	}

#ifdef BUILDDATE

	//char szFileName[]="./version.ini";
	//FILE* fp = fopen(szFileName,"w");

	//char szBuildDate[]="builddate:";
	//fwrite(szBuildDate,sizeof(szBuildDate),1,fp);

	//fwrite(BUILDDATE,sizeof(BUILDDATE),1,fp);
	//fwrite("\n",sizeof("\n"),1,fp);

	//fclose(fp);

	printf("version:%s\n",BUILDDATE);
#endif
	
	int iRet = BX_CreateServer();
	//创建通信服务成功
	if (iRet == 0)
	{
		g_bx_cb_funs = (BX_CB_FUNS *)malloc( sizeof(BX_CB_FUNS) );
		g_InitStat = 1;
	}
	if(g_pBX_JpegBuff == NULL)
		g_pBX_JpegBuff = (BX_Uint8*)malloc(MAX_BUFFLEN);

	return iRet;

}
BX_Int32 BX_UnInit()
{

	BX_Int32 iRet = BX_CloseServer();
	if (g_bx_cb_funs != NULL)
	{
		free(g_bx_cb_funs);
		g_bx_cb_funs = NULL;
	}
	if (g_pBX_JpegBuff != NULL)
	{
		free(g_pBX_JpegBuff);
		g_pBX_JpegBuff = NULL;
	}
	return iRet;
}

BX_Int32 BX_Reg_CB_FUNS( BX_CB_FUNS cb_funs )
{
	if (cb_funs.GetDeviceTime == NULL || 
		cb_funs.SetDeviceTime == NULL ||
		cb_funs.GetDeviceWH == NULL
		)
	{
		return -1;
	}
	g_bx_cb_funs->SetDeviceTime = cb_funs.SetDeviceTime;
	g_bx_cb_funs->GetDeviceTime = cb_funs.GetDeviceTime;
	g_bx_cb_funs->GetDeviceWH = cb_funs.GetDeviceWH;

	return BX_OK;
}

BX_Int32 BX_SendImage( const BX_HeadData *pbxHead,const BX_Uint8 *JpegData, BX_Uint32 picLen )
{

	if (pbxHead == NULL || JpegData == NULL || picLen == 0)
	{
		printf("BX_SendImage picLen=%d\n",picLen);
		return BX_PARAM_ERROR;
	}


	//计算大概需要发送的数据大小

	int sendBuffLen = picLen+sizeof(g_pui8JPEGEmbededData)+sizeof(g_pui8JPEGEmbededPlateRecogData)+
		sizeof(g_pui8JPEGEmbededExposualData)+sizeof(g_pui8JPEGEmbededSubPhotoData)+sizeof(g_pui8JPEGEmbededSecurityCode)
		+sizeof(g_pui8JPEGEmbededWaterMarkData);  //68+258+66+66+24+24=506
	if (sendBuffLen > g_LastSendBuffLen)
	{
		//考虑图片长度大于默认长度
		if (g_pBX_JpegBuff != NULL)
		{
			free(g_pBX_JpegBuff);
			g_pBX_JpegBuff = NULL;
		}
		printf("重新分配发送buff大小，lastlen=%d\n",g_LastSendBuffLen);
		g_pBX_JpegBuff = (BX_Uint8*)malloc(sendBuffLen);
		g_LastSendBuffLen = sendBuffLen;//记录发送结果buff的大小
	}
	memset(g_pBX_JpegBuff,0,sendBuffLen);
	printf("thislen=%d\n",g_LastSendBuffLen);

	
	//配置JPEG基本内嵌信息块
	g_pui8JPEGEmbededData[6] = pbxHead->ui8TotalSnapTimes;
	g_pui8JPEGEmbededData[7] = pbxHead->ui8CurTimes;
	sprintf((char*)(g_pui8JPEGEmbededData+0x40),"%04x",pbxHead->ui32EventID & 0xffff);

	g_pui8JPEGEmbededData[15] = pbxHead->uiCarMarkType;

	sprintf((char*)(g_pui8JPEGEmbededData+16),"%02x,%04d%04x,%07x",
		pbxHead->ui16EventType & 0xff,pbxHead->uiIllegalCode /*& 0xffff*/,pbxHead->uiRoadNo & 0xffff,pbxHead->uiRecordID & 0xffffffff);

	printf("pbxHead->uiIllegalCode = %d,%04x,%s\n",pbxHead->uiIllegalCode,pbxHead->uiIllegalCode & 0xffff,pbxHead->szPlateCode);
	//配置抓拍时间
	char bxtime[7] = {0};
	struct tm *nowtime;
	time_t thisSecond = pbxHead->ui8Time/1000;
	nowtime = localtime( &thisSecond );
	bxtime[0] = nowtime->tm_year+1900-2000;//年
	bxtime[1] = nowtime->tm_mon+1;
	bxtime[2] = nowtime->tm_mday;
	bxtime[3] = pbxHead->ui8Time%1000/10;
	bxtime[4] = nowtime->tm_hour;
	bxtime[5] = nowtime->tm_min;
	bxtime[6] = nowtime->tm_sec;

	memcpy( g_pui8JPEGEmbededData+0x08, bxtime, 7*sizeof(BX_Int8));


	sprintf((char*)(g_pui8JPEGEmbededData+0x3d),"%01x%01x%01x",pbxHead->uiCameraId & 0x0f,
		pbxHead->uiSourceCam & 0x0f,
		pbxHead->uiOtherCam & 0x0f);

	//配置车牌识别信息
	sprintf((char*)(g_pui8JPEGEmbededPlateRecogData+4),"%20s,c=%02d,w=%04d,h=%04d,s=%04d,%04d,%04d,%04d,p=%04d,t=%02d,bc=%02d,%02d,%04d,%04d,A=%04d,%04d,%04d,%04d",
		pbxHead->szPlateCode,pbxHead->ui16PlateColor,0,0,0,0,0,0,0,0,0,0,0,0,
		pbxHead->uiGrayX,
		pbxHead->uiGrayY,
		pbxHead->uiGrayW,
		pbxHead->uiGrayH);
	//add by mawei20151207
	//sprintf((char*)(g_pui8JPEGEmbededPlateRecogData+132),"%s",pbxHead->uiVideoFtpPath);
	memcpy((g_pui8JPEGEmbededPlateRecogData+132),pbxHead->uiVideoFtpPath,sizeof(pbxHead->uiVideoFtpPath));
	//最终写入JPEG头
	
	//2.写入JPEG头

	int moveIndex = 4;
	//基本内嵌信息
	memcpy(g_pBX_JpegBuff+moveIndex,g_pui8JPEGEmbededData,sizeof(g_pui8JPEGEmbededData));
	moveIndex += sizeof(g_pui8JPEGEmbededData);

	//车牌识别信息
	memcpy(g_pBX_JpegBuff+moveIndex,
		g_pui8JPEGEmbededPlateRecogData,sizeof(g_pui8JPEGEmbededPlateRecogData));
	moveIndex += sizeof(g_pui8JPEGEmbededPlateRecogData);


	////配置曝光参数信息（不是必须）
	memcpy(g_pBX_JpegBuff+moveIndex,
		g_pui8JPEGEmbededExposualData,sizeof(g_pui8JPEGEmbededExposualData));
	moveIndex += sizeof(g_pui8JPEGEmbededExposualData);

	//（子图相关的信息）
	memcpy(g_pBX_JpegBuff+moveIndex,
		g_pui8JPEGEmbededSubPhotoData,sizeof(g_pui8JPEGEmbededSubPhotoData));

	moveIndex += sizeof(g_pui8JPEGEmbededSubPhotoData);
	//(图片数字水印)
	memcpy(g_pBX_JpegBuff+moveIndex,
		g_pui8JPEGEmbededWaterMarkData,sizeof(g_pui8JPEGEmbededWaterMarkData));

	moveIndex += sizeof(g_pui8JPEGEmbededWaterMarkData);

	//找到FFC0或者FFDB开始的地方
	int jpegbegin = 0;
	for (jpegbegin =0 ;jpegbegin< picLen-1;jpegbegin++)
	{
		if ( JpegData[jpegbegin] == 0xFF && JpegData[jpegbegin+1] == 0xC0)
		{
			printf("find FF C0 jpegbegin=%d...\n",jpegbegin);
			break;
		}

		if ( JpegData[jpegbegin] == 0xFF && JpegData[jpegbegin+1] == 0xDB)
		{
			printf("find FF DB jpegbegin=%d...\n",jpegbegin);
			break;
		}
	}

	//查找图片结尾FFD9结尾
	int jpegend = 0;
	for (jpegend = picLen ;jpegend != 1;--jpegend)
	{
		if ( JpegData[jpegend-1] == 0xFF && JpegData[jpegend] == 0xD9)
		{
			jpegend++;//需要多一个字节
			printf("find FF D9 jpegend=%d...\n",jpegend);
			break;
		}
	}

	//拷贝开始和结尾之间的数据到缓冲器
	memcpy(g_pBX_JpegBuff+moveIndex,JpegData+jpegbegin,jpegend-jpegbegin);

	//1.先配置JPG图像尺寸
	BX_Uint32 realSendLen = moveIndex+jpegend-jpegbegin;  

	*(BX_Uint32*)g_pBX_JpegBuff = realSendLen - 4;//只是图片的大小
	
	
	printf("realSendLen = %d,moveIndex=%d\n",realSendLen,moveIndex);

	int iRet = BX_45000Send(g_pBX_JpegBuff,realSendLen,pbxHead->uiEventState);
	if (iRet != BX_OK)
	{
		printf("BX_45000Send iRet = %d\n",iRet);
		return -1;
	}

	//宝信服务有问题，需要发送一个冗余字段

	char otherdata[4] = {0};
	
	BX_45000Send(otherdata,sizeof(otherdata),1);
	return 0;
}




